import math
# You are working on a revolutionary video game. In this game the player will be able to collect several types of bonuses on each level, and his total score for the level is equal to the sum of the first n bonuses he collected. However, if he collects less than n bonuses, his score will be equal to 0.

# Given the bonuses the player got, your task is to return his final score for the level.

# Example

# For bonuses = [4, 2, 4, 5] and n = 3,
# the output should be
# calcBonuses(bonuses, n) = 10.

# 4 + 2 + 4 = 10.

# For bonuses = [4, 2, 4, 5] and n = 5,
# the output should be
# calcBonuses(bonuses, n) = 0.

# The player has collected only 4 bonuses, so his final score is 0.


def calcBonuses(bonuses, n):
    it = iter(bonuses)
    res = 0

    try:
        for _ in range(n):
            res += next(it)
    except StopIteration:
        res = 0

    return
# You are working on a revolutionary video game. This game will consist of several levels, and on each level the player will be able to collect bonuses. For each passed level the player will thus get some score, determined by the number of collected bonuses.

# Player's final score is decided by the number of completed levels and scores obtained on each of them. The final score is calculated as the sum of squares of n maximum scores obtained. If the number of completed levels is less than n, the score is calculated as the sum of squared scores for each level, and final result is divided by 5 as a penalty (the result is rounded down to the nearest integer).

# Given the list of scores the player got for completed levels and the number n that determines the number of levels you have to pass to avoid being penalized, return the player's final game score.

# Example

# For scores = [4, 2, 4, 5] and n = 3,
# the output should be
# calcFinalScore(scores, n) = 57.

# 52 + 42 + 42 = 57.

# For scores = [4, 2, 4, 5] and n = 5,
# the output should be
# calcFinalScore(scores, n) = 12.

# (42 + 22 + 42 + 52) / 5 = 61 / 5 â‰ˆ 12.


def calcFinalScore(scores, n):
    gen = iter([x*x for x in sorted(scores, reverse=True)[:n]])

    res = 0
    try:
        for _ in range(n):
            res += next(gen)
    except StopIteration:
        res //= 5

    return res


# Fibonacci sequence is known to every programmer, and you're not an exception. It is believed that not all properties of Fibonacci numbers are yet studied, and in order to help your descendants, you'd like to implement a generator that will generate Fibonacci numbers infinitely. Who knows, maybe in the distant future your generator will help to make a breakthrough in this field!

# To test your generator, you'd like to check the first few values. Given the number n, return the first n numbers of Fibonacci sequence.

# Example

# For n = 3, the output should be
# fibonacciGenerator(n) = [0, 1, 1].

# The first three Fibonacci numbers are 0, 1 and 1.
def fibonacciGenerator(n):
    def fib():
        last = (0, 1)
        while True:
            yield last[0]
            last = last[0] + last[1], last[0]

    gen = fib()
    return [next(gen) for _ in range(n)]

# The Calkin-Wilf tree is a tree in which the vertices correspond 1-for-1 to the positive rational numbers. The tree is rooted at the number 1, and any rational number expressed in simplest terms as the fraction a / b has as its two children the numbers a / (a + b) and (a + b) / b. Every positive rational number appears exactly once in the tree. Here's what it looks like:


# The Calkin-Wilf sequence is the sequence of rational numbers generated by a breadth-first traversal of the Calkin-Wilf tree, where the vertices of the same level are traversed from left to right (as displayed in the image above). The sequence thus also contains each rational number exactly once, and can be represented as follows:


# Given a rational number, your task is to return its 0-based index in the Calkin-Wilf sequence.

# Example
# For number = [1, 3], the output should be
# calkinWilfSequence(number) = 3.

# As you can see in the image above, 1 / 3 is the 3rd 0-based number in the sequenc
def calkinWilfSequence(number):

    def fractions():
        numerator = 1
        denominator = 1
        yield [numerator, denominator]
        while True:
            numerator, denominator = denominator, 2 * \
                (numerator//denominator) * denominator + denominator - numerator
            yield [numerator, denominator]

    gen = fractions()
    res = 0
    while next(gen) != number:
        res += 1
    return res


def checkPassword(attempts, password):
    ''' 
        You're implementing a web application. Like most applications, yours also has the authorization function. Now you need to implement a server function that will check password attempts made by users. Since you expect heavy loads, the function should be able to accept a bunch of requests that will be sent simultaneously.
        In order to validate your function, you want to test it locally. Given a list of attempts and the correct password, return the 1-based index of the first correct attempt, or -1 if there were none.
        Example
        For attempts = ["hello", "world", "I", "like", "coding"] and
        password = "like", the output should be
        checkPassword(attempts, password) = 4.
    '''
    def check():
        while True:
            yield attempt == password

    checker = check()
    for i, attempt in enumerate(attempts):
        next(checker)
        if checker.send(attempt):
            return i + 1

    return -1


class FRange(object):
    '''
    An you may know, the range function in Python allows coders to iterate over elements from start to stop with the given step. Unfortunately it works only for integer values, and additional libraries should be used if a programmer wants to use float values.
    CodeSignal doesn't include third-party libraries, so you have to make do with the standard ones. Given array of arguments args, return array of values the float range generator should return.
    Example
    For args = [5], the output should be
    rangeFloat(args) = [0, 1, 2, 3, 4].
    Since args contains only one element, it corresponds to the stop argument. start and step arguments have default parameters, which are 0 and 1, respectively.
    For args = [0.5, 7.5], the output should be
    rangeFloat(args) = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5].
    There are only two elements in args, which means that the first value corresponds to start, and the second value corresponds to stop. The step argument thus has a default value, which is 1.
    For args = [-1.1, 2.4, 0.3], the output should be
    rangeFloat(args) = [-1.1, -0.8, -0.5, -0.2, 0.1, 0.4, 0.7, 1, 1.3, 1.6, 1.9, 2.2].
    Since args contains all three elements, the values of start, stop and step are -1.1, 2.4 and 0.3, respectively.
    '''

    def __init__(self, start, stop=None, step=None):
        if stop is None:
            self.i = 0
            self.stop = start
            self.step = 1
        elif step is None:
            self.i = start
            self.stop = stop
            self.step = 1
        else:
            self.i = start
            self.stop = stop
            self.step = step

    def __iter__(self):
        return self

    def __next__(self):
        if self.step >= 0:
            if self.i < self.stop:
                self.i += self.step
                return (self.i - self.step)
            else:
                raise StopIteration

        else:
            if self.i > self.stop:
                self.i += self.step
                return (self.i - self.step)
            else:
                raise StopIteration


def rangeFloat(args):
    return list(FRange(*args))


class Prizes(object):
    '''
    In a large and famous supermarket a new major campaign was launched. From now on, each nth customer has a chance to win a prize: a brand new luxury car! However, it's not that simple. A customer wins a prize only if the total price of their purchase is divisible by d. This number is kept as a secret, so the customers don't know in advance how much they should spend on their purchases. The winners will be announced once the campaign is over.
    Your task is to implement a function that will determine the winners. Given the purchases of some customers over time, return the 1-based indices of all the customers who won the prize, i.e. each nth who spend on their purchases amount of money divisible by d.
    Example
    For purchases = [12, 43, 13, 465, 1, 13], n = 2, and d = 3,
    the output should be
    superPrize(purchases, n, d) = [4].
    Each second customer has a chance to win a car, which makes customers 2, 4 and 6 potential winners. Customer number 2 spent 43 on his purchase, which is not divisible by 3. 13 also is not divisible by 3, so the sixth customer also doesn't get the price. Customer 4, however, spent 465, which is divisible by 3, so he is the only lucky guy.
    '''

    def __init__(self, purchases, n, d):
        self.purchases = purchases
        self.n = n
        self.d = d
        self.index = n - 1

    def __iter__(self):
        return self

    def won(self):
        return self.purchases[self.index - self.n] % self.d == 0

    def __next__(self):

        while self.index < len(self.purchases):
            self.index += self.n
            if self.won():
                self.winner = (self.index - self.n + 1)
                return self.winner
        raise StopIteration


def superPrize(purchases, n, d):
    return list(Prizes(purchases, n, d))


def main():
    attempts = ["hello",
                "world",
                "I",
                "like",
                "coding"]

    password = "like"
    print(checkPassword(attempts, password))  # Expected result = 4
# # bonuses = [4, 2, 4, 5]
# number = [1931, 1076]
# print(calkinWilfSequence(number))
# # print(calcBonuses(bonuses,3))


if __name__ == '__main__':
    main()
